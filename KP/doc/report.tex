\documentclass[12pt]{extarticle}

\usepackage{amsmath,amsthm,amssymb}
\usepackage{mathtext}
\usepackage[utf8]{inputenc}
\usepackage[english, russian]{babel}
\usepackage{blindtext}
\usepackage{fancyhdr}
\usepackage{listings}
%\usepackage[left=3cm, right=1cm, top=2cm, bottom=2cm]{geometry}

\usepackage{fontspec} 
\setmainfont{Times New Roman}

\fancypagestyle{specialfooter}{%
	\fancyhf{}
	\renewcommand\headrulewidth{0pt}
	\fancyfoot[C]{Москва, 2023}
}

\setlength{\parindent}{1.25cm}

\newcommand\tline[2]{$\underset{\text{#1}}{\text{\underline{\hspace{#2}}}}$}

\linespread{1}

\begin{document}

	\input{src/title}
	
	\tableofcontents
	
	\newpage
	
	\begin{sloppypar}	
	
	\section{Введение}
	
	Современный мир наполнен, если не переполнен, производными информационных технологий. В некотором смысле можно сказать, что современный мир полостью зависим от информационных технологий и, как следствие, программирования. А от чего же зависит само программирование? Ответ лежит на поверхности: программирование - процесс, зависимый от того или иного средства разработки, которые, в свою очередь, создавались при помощи других средств разработки. Продолжив углубляться в тему зависимостей программирования, мы с вами придём к единицам и нулям - машинным кодам, послужившим средством разработки в семидесятые годы прошлого века посредством перфокарт. Однако, современному <<разработчику>> такое программирование покажется пыткой, как и средство разработки <<уровнем выше>> в модели абстракций программирования - <<assembly>> - неминуемый этап в создании средств разработки, используемый повсеместно прямо или косвенно.
	
	\par
	
	Программирование на <<assembly>> на сегодняшний день весьма неактуально ввиду трудоёмкости написания программ - всё же мы обращаемся напрямую к процессору. Проблеме трудоёмкости программирования человечество нашло решение ещё в прошлом веке, задавашисб вопросом: Что если <<шагнуть>> от процессора и создать более <<дружелюбный>> для разработчиков язык? Таким образом повились первые компиляторы, а вместе с ними и высокоуровненвые языки программирования, в том числе и мощнейший и актульный по сей день C.
	
	\section{Определение инструментов разработки}
	
	Чтобы перейти к выполнению поставленной задачи - разработке транслирующей грамматики, переводящей логическое выраджение из инфиксной записи в постфиксную, определим инструменты, которыми мы будем пользоваться.
	
	\subsection{Обратная польская запись}
	
	Инфиксная форма - самая распространнёная форма, так как для человека она проще для представления. Она представляет из себя выражение, в котором операторы располагаются между операндами. Отсюда исходит название данной формы.
	Пример инфиксной формы:
	
	\[
		a \cup b \cap c
	\]
	
	Префиксная же форма представляет из себя выражение, в котором операторы находятся перед операндами:
	
	\[
		\cap c \cup ab
	\]
	
	Соответственно, постфиксная форма представляет из себя выражение, в котором оператор находится после операндов:
	
	\[
		ab \cup c \cap
	\]
	
	\subsection{Контекстно-свободная грамматика}
	
	Поскольку транслирующая грамматика - подмножество множества контекстно-свободных грамматик, определим для начала КС-грамматику. В классификации Хомского КС-грамматика - грамматика, распознаваемая распознавателем - МП-автоматом (автоматом с магазинно-стековой памятью). Более строго грамматика $G=(T, \, V, \, P, \, S_0)$ называется контекстно-свободной, если каждое правило $p \in P$ имеет вид $A \rightarrow \alpha : \; A \subset V, \, \alpha \subset (T \cup V)^*$.
	
	\subsection{Транслирующая грамматика}
	
	Дадим сразу формальное определение. Пятёрка объектов $G^T = (V, \Sigma_i, \Sigma_a, P, S)$, характеризующая КС-грамматику, где $\Sigma_i$ - множество входных символов, $\Sigma_a$ - множество операционных символов, $V$ - множество нетерминальных символов, $S \in V$ - начальный символ грамматики, $P$ - конечное множество правил вывода вида $A \rightarrow \alpha : \; A \in V, \, \alpha \in (\Sigma_i \cup \Sigma_a \cup V)^*$, называется транслирующей грамматикой, если её множество терминалов разбито на множества входных и операционных символов - $\Sigma_i$ и $\Sigma_a$ соответственно.
	
	\section{Первичный анализ}
	
	Итак. задача поставлена: на вход подаётся логическое выражение в инфиксной записи, состоящее из трёх логических операций: отрицание, объединения и пересечения, на выходе требуется получить эквивалентное выражение в польской нотации.
	
	\par 
	
	Определим приоритеты операций: 
	
	\par
	
	\noindent Таблица 1 - Приоритеты операций
	
	
	\begin{center}	
		\begin{tabular}{| c | c |}
			\hline
			Приоритет & Операция \\
			\hline
			1 & $\neg$ \\
			\hline
			2 & $\cap$ \\
			\hline
			3 & $\cup$ \\
			\hline
		\end{tabular}
	\end{center}
	
	Также обратим внимание на то, что мы имеем дело с двумя двуместными операторами <<и>>, <<или>> - $\cap, \, \cup$ и одним одноместым - <<не>> - $\neg$. Таким образом задача сводится к проектирвоанию транслирующей грамматики, обрабатывающей всего три операнда.
	
	\section{Описание алгоритма}
	
	Правило $p_i \in P$ транслирующей грамматики имеет вид:
	
	\[
		A \rightarrow \alpha, : \{\beta\} : \; A \in V, \, \beta \in \Sigma_a \, \alpha \in (\Sigma_i \cup \Sigma_a \cup V)^*.
	\]
	
	Проще говоря, в фигурных скобках указывается операционный символ, подлежащий вствке в выходную цепочку. Принцип работы транслирующей грамматики схож с принципом работы синтаксически управляемой схемы, более того, это два различных способа описать по сути один и тот же процесс.
	
	Опишем алгоритмы действий для всех возоможных случаев.
	
	\subsection{Отрицание}
	
	Как уже говорилось, отрицание - олноместная операция, следовательно для приведения логического выражения с отрицанием из инфиксной записи в <<ПОЛИЗ>> достаточно поменять местами оператор и опреранд.
	
	\[
		\neg a \longrightarrow a \neg .
	\]
	
	\subsection{Конъюнкция}
	
	Конънкция же двуместная операция, алгоритм приведения выражения к польской нотации иной: поменять местами правый операнд и оператора.
	
	\[
		a \cap b \longrightarrow a b \cap.
	\]
	
	\subsection{Дизъюнкция}
	
	Алгоритм преобразования двуместных операторов, коим, как уже говорилось, и является дизъюнкция, приведён в примере для конъюнкции.
	
	\[
		a \cup b \longrightarrow a b \cup.
	\]
	
	\section{Построение транслирующей грамматики}
	
	Для наглядности и простоты понимания ограничим множество булевых переменных одним элементом - $i$, тем не менее, забегая вперёд, важно отметить, что правила для алфавита с одним элементом вида 
	
	\begin{itemize}
		\item[--] $B \rightarrow B \cap A$,
		\item[--] $A \rightarrow i, \; A \in V, \, i \in \Sigma_i \cup \Sigma_a$
	\end{itemize}
	
	для алфавита мощности $n$ преобразуются в правила вида
	
	\begin{itemize}
		\item[--] $B_1 \rightarrow B_1 \cap A_1$,
		\item[--] $A_1 \rightarrow \alpha_1, \; A_1 \in V, \, \alpha_1 \in \Sigma_i \cup \Sigma_a$  \\
		
		\hfil \vdots

		\item[--] $B_n \rightarrow B_n \cap A_n$,
		\item[--] $A_n \rightarrow \alpha_n, \; A_n \in V, \, \alpha_n \in \Sigma_i \cup \Sigma_a$ 	
	\end{itemize}
	
	Рассмотрим возможные случаи, сразу продумывая правила транслирующей грамматики.
	
	\subsection{Одноместная операция}
	
	Если входной символ является оператором отрицания - $\neg$, это значит, что уже был прочитан его операнд и в выходную последовательность необходимо записать сам операнд и оператор.
	
	 \subsection{Двуместные операции}
	 
	 Если входной символ является оператор конъюнкции - $\cap$ или оператор дизъюнкции - $\cup$, это значит, что уже был прочитан первый операнд и нам следует его записать в выходную последовательность. Следующим действием будет прочтение второго операнда и запись как второго операнда, так и оператора в выходную последовательность.
	 
	 \subsection{Определение транслирующей грамматики}
	 
	 Начнём с очевидного - определения алфавита грамматики.
	 \begin{gather*}
	 	G^T = (V, \Sigma_i, \Sigma_a, P, S), \\
	 	V = \{A\}, \\
	 	\Sigma_i = \{i, \, \neg, \, \cap, \, \cup\}, \\
	 	\Sigma_a = \{i, \, \neg, \, \cap, \, \cup\}, \\
	 	S = \{S_0\}, \\
	 	P = \{ \\
	 	p_1 :\; S_0 \rightarrow S_0 \cup A \, \{ \cup \}, \\
	 	p_2 :\; S_0 \rightarrow S_0 \cap A \, \{ \cap \}, \\
	 	p_3 :\; S_0 \rightarrow \neg A S_0 \, \{ \neg \}, \\
	 	p_4 :\; S_0 \rightarrow A, \\
	 	p_5 :\; A \rightarrow i \{ i \}, \\
	 	\}
	 \end{gather*}
		
	Выполним перевод цепочки $\neg i \cup i \cap i$:
	
	\begin{itemize}
		\item $2. \cup$
		\item $4. i \cup$
		\item $4. i i \cup$
		\item $1. \cap i i \cup$
		\item $4. i \cap i i \cup$
		\item $3. \neg i \cap i i \cup$
		\item $4. i \neg i \cap i i \cup$
	\end{itemize}
	
	
	\section{Написание программы}
	
	\subsection{Алгоритм Дейкстры}
	
	Для преобразования в постфиксную форму будем использовать улучшенный Эдсгером Вибе Дейкстрой алгоритм. Принцип работы алгоритма Дейкстра:
	
	\begin{itemize}
		
		\item Проходим исходную строку;
		\item При нахождении числа, заносим его в выходную строку;
		\item При нахождении оператора, заносим его в стек;
		\item Выталкиваем в выходную строку из стека все операторы, имеющие приоритет выше рассматриваемого;
		\item При нахождении открывающейся скобки, заносим её в стек;
		\item При нахождении закрывающей скобки, выталкиваем из стека все операторы до открывающейся скобки, а открывающуюся скобку удаляем из стека.
		
	\end{itemize}
	
	\subsection{Листинг программы}
	
 	\scriptsize \lstinputlisting[language=C]{../InfixToPostfix.cs}
 	
 	\normalsize
 	
 	\newpage
 	
 	\subsection{Пример работы программы}
 	
 	\begin{verbatim}
 		InFix   :	a+b*c-d
 		PostFix :	abc*+d-
 		
 		InFix   :	a+b*c-d/e*f
 		PostFix :	abc*+de/f*-
 		
 		InFix   :	a-b/c*d-e--f/h*i++j-/k
 		PostFix :	abc/d*-e--fh/i*-+j+k/-
 	\end{verbatim}
 	
 	\section{Вывод}
 	
 	По результатам проделанной работы стало понятно, что уже более-менее умеющим программировать людям бывает тяжело погрузиться в теорию кмпиляторов, заставляя себя отказываться от мощных утилит высокоуровнего программирования. Тем не менее <<выжить в условиях assembly>> можно, и эта работа в том числе подтвердила это уверждение.
		
	\end{sloppypar}

\end{document}